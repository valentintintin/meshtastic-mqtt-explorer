@page "/packet/{id:long}"
@page "/packet/by-packetid/{packetId:long}"

@implements IAsyncDisposable

@using System.Globalization
@using Common.Context
@using Common.Context.Entities
@using Common.Extensions
@using Common.Extensions.Entities
@using Common.Services
@using Microsoft.EntityFrameworkCore
@using MeshtasticMqttExplorer.Components.Shared

@inject IDbContextFactory<DataContext> ContextFactory
@inject IMessageService Message
@inject MeshtasticService MeshtasticService

<PageTitle>Détail du packet @Packet?.PacketId</PageTitle>

<Spin Spinning="Loading">
    @if (Packet != null)
    {
        <PageHeader Title="@($"Trame #{Packet?.PacketId} {Packet?.PortNum} du noeud {Packet?.From.NodeIdString} pour {Packet?.To.NodeIdString}")" 
                    Subtitle="@Packet?.CreatedAt.ToFrench().ToString(CultureInfo.CurrentCulture)"></PageHeader>

        <Timeline>
            <TimelineItem Color="blue">
                Expéditeur : <a href="/node/@Packet.FromId" target="_blank" rel="nofollow">@Packet.From.AllNames</a>
            </TimelineItem>
            <TimelineItem Color="red">
                Destinataire: <a href="/node/@Packet.ToId" target="_blank" rel="nofollow">@Packet.To.AllNames</a>
            </TimelineItem>
            
            <TimelineItem Color="green">
                Passerelle MQTT : <a href="/node/@Packet.GatewayId" target="_blank" rel="nofollow">@Packet.Gateway.AllNames</a>
                <br />
                Distance de <b>@Math.Round(Packet.GatewayDistanceKm ?? 0, 2) Km</b> - <b>@Math.Abs(Packet.HopStart - Packet.HopLimit ?? 0)</b> sauts
                <br />
                SNR : <b>@Packet.RxSnr</b> | RSSI : <b>@Packet.RxRssi</b>
            </TimelineItem>
        </Timeline>
        
        @if (Packet.PacketDuplicated != null)
        {
            <p>
                <text>Doublon avec </text><a href="/packet/@Packet.PacketDuplicatedId" target="_blank" rel="nofollow">un autre</a>
            </p>
        }
        
        @if (Packet.RequestId > 0)
        {
            <p>
                <text>Réponse à la requête </text><a href="/packet/by-packetid/@Packet.RequestId" target="_blank" rel="nofollow">#@Packet.RequestId</a>
            </p>
        }
        
        @if (Packet.ReplyId > 0)
        {
            <p>
                <text>Réponse au paquet </text><a href="/packet/by-packetid/@Packet.ReplyId" target="_blank" rel="nofollow">#@Packet.ReplyId</a>
            </p>
        }
        
        <PacketPayload Packet="Packet" ShowJson="true"></PacketPayload>
        
        <Button OnClick="() => ComputeAgain()">Traiter la trame</Button>
    }
    else if (Loading)
    {
        <Skeleton></Skeleton>
    }
    else
    {
        <Result Title="Paquet introuvable" Status="404"></Result>
    }
</Spin>

@code
{
    [Parameter]
    public long? Id { get; set; }
    
    [Parameter]
    public long? PacketId { get; set; }

    private bool Loading { get; set; } = true;
    private Packet? Packet { get; set; }
    private DataContext Context { get; set; } = null!;

    protected override async Task OnInitializedAsync()
    {
        Context = await ContextFactory.CreateDbContextAsync();

        await FetchData();

        await base.OnInitializedAsync();
    }

    private async Task FetchData()
    {
        Loading = true;
        
        var query = Context.Packets
            .Include(n => n.From)
            .Include(n => n.To)
            .Include(n => n.Gateway)
            .AsNoTrackingWithIdentityResolution()
        ;

        if (Id.HasValue)
        {
            Packet = await query.FindByIdAsync(Id);
        }
        else if (PacketId != 0 && PacketId.HasValue)
        {
            Packet = await query.FindByPacketIdAsync((uint) PacketId.Value);
        }

        if (Packet == null)
        {
            Loading = false;

            return;
        }
        
        Loading = false;
    }

    private async Task ComputeAgain()
    {
        await MeshtasticService.DoReceive(Packet);
        await Message.Info("Trame traitée !");
    }

    public async ValueTask DisposeAsync()
    {
        await Context.DisposeAsync();
    }
}