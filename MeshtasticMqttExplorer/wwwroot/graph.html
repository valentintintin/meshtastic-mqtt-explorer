
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>
   Meshtastic MQTT Explorer - Graph des noeuds
  </title>

  <style>
   body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    background-color: black;
   }
   svg {
    width: 100%;
    height: 100%;
   }
   .node text {
    font-family: sans-serif;
    fill: #fff;
    text-anchor: middle;
    dominant-baseline: middle;
   }
   .link.bidirectional {
    stroke: #555;
   }
   .link.bidirectional-highlight {
    stroke: #fff;
   }
   .link.unidirectional-red {
    stroke: #400;
   }
   .link.unidirectional-green {
    stroke: #040;
   }
   .link.unidirectional-red-highlight {
    stroke: #f00;
   }
   .link.unidirectional-green-highlight {
    stroke: #0f0;
   }
   .search-bar {
    position: absolute;
    top: 6px;
    left: 5px;
    z-index: 10;
    font: 12px sans-serif;
    padding: 2px;
    width: 350px;
    background-color: #333;
    color: white;
    border: 0px solid;
   }
   .results {
    font: 12px sans-serif;
    position: absolute;
    top: 30px;
    left: 5px;
    z-index: 10;
    background-color: #222;
    color: white;
    padding: 2px;
    width: 350px;
    bottom: 5px;
    overflow-y: auto;
    border: 0px solid;
    display: none;
   }
   .results div {
    padding: 2px;
    cursor: pointer;
   }
   .results .separator, .results .separator:hover {
    text-align: center;
    color: #fff;
    background-color: #000;
    font-weight: bold;
    cursor: default;
   }
   .results div:hover {
    background-color: #111;
   }
   .tooltip {
    position: fixed;
    top: 30px;
    left: 5px;
    width: auto;
    height: auto;
    font: 12px sans-serif;
    color: white;
    pointer-events: none;
   }
   .tooltip b {
    color: #0f0;
   }
   .shortname {
    display: inline-block;
    text-align: center;
    width: 5ch;
    color: white;
    font-family: monospace;
   }
   .bottom {
    position: absolute;
    bottom: 5px;
    left: 0px;
    width: 100%;
    text-align: center;
    font: 12px sans-serif;
    color: white;
   }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>

  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=yes" />
  <link rel="icon" href="favicon.png" type="image/png" />
 </head>
 <body>
  <input type="text" class="search-bar" placeholder="Search node..." />
  <div class="results"></div>
  <svg></svg>
  <script>
   function getShortnameColor(role) {
    switch(role) {
     case "CLIENT":
      return "#080";
     case "CLIENT_MUTE":
      return "#00f";
     case "ROUTER":
      return "#80f";
     default:
      return "#800";
    }
   }

   let blinkInterval;

   const tooltip = d3.select("body").append("div")
   .attr("class", "tooltip");

   const nodeSize = 25;
   const arrowSize = 6;
   let simulation;
   let zoomState = d3.zoomIdentity;
   let selectedNode = null;

   const zoom = d3.zoom().on("zoom", (event) => {
    d3.select("g").attr("transform", event.transform);
    zoomState = event.transform;
   });

   fetch("/graph?_=" + new Date().getTime()).then(response => response.json()).then(data => {
    const initialData = JSON.parse(JSON.stringify(data));

    function getMeshForNode(data, nodeId) {
     const visited = new Set();
     const stack = [nodeId];
     const component = new Set();

     while(stack.length > 0) {
      const id = stack.pop();
      if(!visited.has(id)) {
       visited.add(id);
       component.add(id);
       const neighbors = data.links
        .filter(link => link.source === id || link.target === id)
        .map(link => (link.source === id ? link.target : link.source))
        .filter(neighborId => !visited.has(neighborId));
       stack.push(...neighbors);
      }
     }

     const filteredNodes = data.nodes.filter(node => component.has(node.id));
     const filteredLinks = data.links.filter(link =>
      component.has(link.source) && component.has(link.target)
     );

     return {nodes: filteredNodes, links: filteredLinks};
    }

    function getConnectedComponents(data) {
     const components = [];
     const visited = new Set();

     data.nodes.forEach(node => {
      if(!visited.has(node.id)) {
       const component = getMeshForNode(data, node.id).nodes;
       component.forEach(n => visited.add(n.id));
       components.push(component);
      }
     });

     components.sort((a, b) => b.length - a.length);

     return components;
    }

    function reloadSimulation(mesh) {
     d3.select("svg").selectAll("*").remove();

     const svg = d3.select("svg");
     const g = svg.append("g");

     svg.call(zoom);
     svg.call(zoom.transform, zoomState);

     g.append("defs").append("marker")
      .attr("id", "arrowhead-green")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 5)
      .attr("refY", 0)
      .attr("orient", "auto")
      .attr("markerWidth", arrowSize)
      .attr("markerHeight", arrowSize)
      .append("path")
      .attr("d", "M 0,-5 L 10,0 L 0,5")
      .attr("fill", "#0f0");

     g.append("defs").append("marker")
      .attr("id", "arrowhead-green-start")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 5)
      .attr("refY", 0)
      .attr("orient", "auto-start-reverse")
      .attr("markerWidth", arrowSize)
      .attr("markerHeight", arrowSize)
      .append("path")
      .attr("d", "M 0,-5 L 10,0 L 0,5")
      .attr("fill", "#0f0");

     g.append("defs").append("marker")
      .attr("id", "arrowhead-red")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 5)
      .attr("refY", 0)
      .attr("orient", "auto")
      .attr("markerWidth", arrowSize)
      .attr("markerHeight", arrowSize)
      .append("path")
      .attr("d", "M 0,-5 L 10,0 L 0,5")
      .attr("fill", "#f00");

     g.append("defs").append("marker")
      .attr("id", "arrowhead-red-start")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 5)
      .attr("refY", 0)
      .attr("orient", "auto-start-reverse")
      .attr("markerWidth", arrowSize)
      .attr("markerHeight", arrowSize)
      .append("path")
      .attr("d", "M 0,-5 L 10,0 L 0,5")
      .attr("fill", "#f00");

     const linkLayer = g.append("g").attr("class", "links");
     const nodeLayer = g.append("g").attr("class", "nodes");
     const arrowLayer = g.append("g").attr("class", "arrows");

     const linkMap = new Map();
     mesh.links.forEach(link => {
      const key = `${link.source}-${link.target}`;
      const reverseKey = `${link.target}-${link.source}`;

      if(linkMap.has(reverseKey)) {
       const reverseLink = linkMap.get(reverseKey);
       reverseLink.bidirectional = true;
       reverseLink.snr = (reverseLink.snr + link.snr) / 2;
      } else if(!linkMap.has(key)) {
       link.bidirectional = false;
       linkMap.set(key, link);
      } else {
       const existingLink = linkMap.get(key);
       existingLink.bidirectional = true;
       existingLink.snr = (existingLink.snr + link.snr) / 2;
      }
     });

     const filteredLinks = [...linkMap.values()];

     linkLayer.selectAll(".link.unidirectional-red")
      .data(filteredLinks.filter(d => !d.bidirectional))
      .enter().append("line")
      .attr("class", "link unidirectional-red");

     linkLayer.selectAll(".link.unidirectional-green")
      .data(filteredLinks.filter(d => !d.bidirectional))
      .enter().append("line")
      .attr("class", "link unidirectional-green");

     linkLayer.selectAll("line.bidirectional")
      .data(filteredLinks.filter(d => d.bidirectional))
      .enter().append("line")
      .attr("class", "link bidirectional");

     const node = nodeLayer.selectAll("g")
      .data(mesh.nodes)
      .enter().append("g")
      .attr("class", "node")
      .attr("data-id", d => d.id)
      .style("cursor", "move")
      .on("mouseover", function(event, d) {
       stopBlinking();
       startBlinking(this, d);
       showTooltip(d);
      })
      .on("mouseout", function(event, d) {
       stopBlinking();
       hideTooltip();
      })
      .call(d3.drag()
       .on("start", dragstarted)
       .on("drag", dragged)
       .on("end", dragended));

     node.append("circle")
      .attr("r", nodeSize)
      .attr("fill", d => getShortnameColor(d.role))
      .attr("opacity", 0.5);

     node.append("text")
      .attr("x", 0)
      .attr("y", 0)
      .text(d => d.short_name)
      .style("font-size", d => /\p{Extended_Pictographic}/u.test(d.short_name) ? "18px" : "12px");

     arrowLayer.selectAll("line")
      .data(filteredLinks)
      .enter().append("line")
      .attr("class", "arrow")
      .attr("marker-end", d => d.bidirectional || !d.unidirectional ? "url(#arrowhead-green)" : "url(#arrowhead-red)")
      .attr("marker-start", d => d.bidirectional ? "url(#arrowhead-green-start)" : "url(#arrowhead-red-start)");

     simulation = d3.forceSimulation(mesh.nodes)
      .force("link", d3.forceLink(filteredLinks).id(d => d.id).distance(d => 220 - d.snr * 15))
      .force("charge", d3.forceManyBody().strength(-200))
      .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
      .force("collide", d3.forceCollide().radius(30))
      .alphaDecay(0.005)
      .alphaMin(0.001);

     simulation.on("tick", () => {
      linkLayer.selectAll("line.unidirectional-red")
       .each(function(d) {
        const middle = getMiddle(d.source, d.target);
        d3.select(this)
         .attr("x1", middle.x)
         .attr("y1", middle.y)
         .attr("x2", adjustPosition(d.target, d.source, nodeSize).targetX)
         .attr("y2", adjustPosition(d.target, d.source, nodeSize).targetY);
       });

      linkLayer.selectAll("line.unidirectional-green")
       .each(function(d) {
        const middle = getMiddle(d.source, d.target);
        d3.select(this)
         .attr("x1", adjustPosition(d.source, d.target, nodeSize).sourceX)
         .attr("y1", adjustPosition(d.source, d.target, nodeSize).sourceY)
         .attr("x2", middle.x)
         .attr("y2", middle.y);
       });

      linkLayer.selectAll("line.unidirectional-red-highlight")
       .each(function(d) {
        const middle = getMiddle(d.source, d.target);
        d3.select(this)
         .attr("x1", middle.x)
         .attr("y1", middle.y)
         .attr("x2", adjustPosition(d.target, d.source, nodeSize).targetX)
         .attr("y2", adjustPosition(d.target, d.source, nodeSize).targetY);
       });

      linkLayer.selectAll("line.unidirectional-green-highlight")
       .each(function(d) {
        const middle = getMiddle(d.source, d.target);
        d3.select(this)
         .attr("x1", adjustPosition(d.source, d.target, nodeSize).sourceX)
         .attr("y1", adjustPosition(d.source, d.target, nodeSize).sourceY)
         .attr("x2", middle.x)
         .attr("y2", middle.y);
       });

      linkLayer.selectAll("line.bidirectional")
       .each(function(d) {
        d3.select(this)
         .attr("x1", adjustPosition(d.target, d.source, nodeSize).sourceX)
         .attr("y1", adjustPosition(d.target, d.source, nodeSize).sourceY)
         .attr("x2", adjustPosition(d.source, d.target, nodeSize).targetX)
         .attr("y2", adjustPosition(d.source, d.target, nodeSize).targetY);
       });

      node.attr("transform", d => `translate(${d.x},${d.y})`);

      arrowLayer.selectAll("line")
       .each(function(d) {
        d3.select(this)
         .attr("x1", adjustPosition(d.target, d.source, nodeSize - arrowSize / 2).sourceX)
         .attr("y1", adjustPosition(d.target, d.source, nodeSize - arrowSize / 2).sourceY)
         .attr("x2", adjustPosition(d.source, d.target, nodeSize - arrowSize / 2).targetX)
         .attr("y2", adjustPosition(d.source, d.target, nodeSize - arrowSize / 2).targetY);
       });
     });
    }

    function startBlinking(nodeElement, d) {
     highlightNode(nodeElement, d);
     function toggleHighlight() {
      const isHighlighted = d3.select(nodeElement).select("circle").attr("opacity") == 1;
      if(isHighlighted)
       unhighlightNode(nodeElement, d);
      else
       highlightNode(nodeElement, d);
     }
     blinkInterval = setInterval(toggleHighlight, 50);
    }

    function stopBlinking() {
     clearInterval(blinkInterval);
     d3.selectAll(".node circle").attr("opacity", 0.5);
     d3.selectAll(".link").classed("bidirectional-highlight", false)
      .classed("unidirectional-red-highlight", false)
      .classed("unidirectional-green-highlight", false);
    }

    function highlightNode(nodeElement, d) {
     d3.select(nodeElement).select("circle").attr("opacity", 1);

     d3.selectAll(".link.unidirectional-red")
      .classed("unidirectional-red-highlight", l => l.source.id === d.id || l.target.id === d.id);

     d3.selectAll(".link.unidirectional-green")
      .classed("unidirectional-green-highlight", l => l.source.id === d.id || l.target.id === d.id);

     d3.selectAll(".link").filter(l => l.source.id === d.id || l.target.id === d.id)
      .classed("bidirectional-highlight", l => l.bidirectional)
      .raise();
    }

    function unhighlightNode(nodeElement, d) {
     d3.select(nodeElement).select("circle").attr("opacity", 0.5);

     d3.selectAll(".link").classed("bidirectional-highlight", false)
      .classed("unidirectional-red-highlight", false)
      .classed("unidirectional-green-highlight", false);
    }

    function showTooltip(d) {
     let updatedDate = new Date(d.updated_at * 1000);
     updatedDate.setMinutes(updatedDate.getMinutes() - updatedDate.getTimezoneOffset());

     let tooltipHtml = "<b>Name</b> <span class=\"shortname\" style=\"background-color: " + getShortnameColor(d.role) + ";\">" + d.short_name + "</span> " + d.long_name +
                       "<br><b>MAC</b> <span style=\"color: #ff0;\">" + d.id.toString(16) + "</span> " + d.id +
                       "<br><b>Updated</b> " + updatedDate.toLocaleString();

     let neighborsUpdatedDate = new Date(d.neighbours_updated_at * 1000);
     neighborsUpdatedDate.setMinutes(neighborsUpdatedDate.getMinutes() - neighborsUpdatedDate.getTimezoneOffset());

     if(d.neighbours_updated_at === null)
      tooltipHtml += "<br><b>Neighbors</b> <span style=\"background-color: #800;\">Neighbor Info disabled</span>";
     else
      tooltipHtml += "<br><b>Neighbors</b> " + neighborsUpdatedDate.toLocaleString();

     if(d.role === "ROUTER_CLIENT")
      tooltipHtml += "<br><b>Role</b> <span style=\"background-color: #800;\">ROUTER_CLIENT is deprecated</span>";
     else
      tooltipHtml += `<br><b>Role</b> <span style="background-color: ${getShortnameColor(d.role)};">${d.role}</span>`;

     tooltipHtml += "<br><b>Hardware</b> " + d.hardware_model;

     if(d.battery_level !== null) {
      if(d.battery_level === 101)
       tooltipHtml += "<br><b>Battery</b> Plugged In";
      else
       tooltipHtml += "<br><b>Battery</b> " + d.battery_level + " %";
     }

     if(d.voltage !== null)
      tooltipHtml += "<br><b>Voltage</b> " + Number(d.voltage).toFixed(2) + " V";
     if(d.air_util_tx !== null)
      tooltipHtml += "<br><b>TX</b> " + Number(d.air_util_tx).toFixed(1) + " %";
     if(d.channel_utilization !== null)
      tooltipHtml += "<br><b>RX</b> " + Number(d.channel_utilization).toFixed(1) + " %";
     if(d.temperature !== null)
      tooltipHtml += "<br><b>Temperature</b> " + Number(d.temperature).toFixed(1) + " °C";
     if(d.relative_humidity !== null)
      tooltipHtml += "<br><b>Humidity</b> " + Number(d.relative_humidity).toFixed(1) + " %";
     if(d.barometric_pressure !== null)
      tooltipHtml += "<br><b>Pressure</b> " + Number(d.barometric_pressure).toFixed(1) + " hPa";
     tooltip.html(tooltipHtml);
     tooltip.style("visibility", "visible");
    }

    function hideTooltip() {
     tooltip.style("visibility", "hidden");
    }

    function populateSearchResults() {
     const components = getConnectedComponents(initialData);
     resultsDiv.innerHTML = "";

     const singleNodes = [];

     components.forEach((component, index) => {
      const mesh = getMeshForNode(initialData, component[0].id);
      const numberOfLinks = mesh.links.length;

      if(component.length > 1) {
       const separator = document.createElement("div");
       separator.className = "separator";
       separator.setAttribute("data-entete", "true");
       separator.textContent = `Mesh with ${component.length} nodes and ${numberOfLinks} links`;
       resultsDiv.appendChild(separator);

       component.forEach((node) => {
        const resultDiv = document.createElement("div");
        resultDiv.setAttribute("data-entete", "false");

        resultDiv.innerHTML = `<span class=\"shortname\" style=\"background-color: ${getShortnameColor(node.role)};\">${node.short_name}</span> ${node.long_name} <span style=\"color: #ff0;\">${node.id.toString(16)}</span>`;
        resultDiv.addEventListener("mousedown", () => {
         resultsDiv.style.display = "none";
         const freshData = JSON.parse(JSON.stringify(initialData));
         const selectedMesh = getMeshForNode(freshData, node.id);
         reloadSimulation(selectedMesh);

         if(selectedNode)
          unhighlightNode(selectedNode.element, selectedNode.data);

         const nodeElement = d3.select(`[data-id="${node.id}"]`).node();
         selectedNode = {element: nodeElement, data: node};
         startBlinking(selectedNode.element, selectedNode.data);
         showTooltip(node);
        });

        resultsDiv.appendChild(resultDiv);
       });
      } else
       singleNodes.push(component[0]);
     });

     if(singleNodes.length > 0) {
      const separator = document.createElement("div");
      separator.className = "separator";
      separator.setAttribute("data-entete", "true");
      separator.textContent = `${singleNodes.length} nodes without neighbors`;
      resultsDiv.appendChild(separator);

      singleNodes.forEach((node) => {
       const resultDiv = document.createElement("div");
       resultDiv.setAttribute("data-entete", "false");
       resultDiv.innerHTML = `<span class=\"shortname\" style=\"background-color: ${getShortnameColor(node.role)};\">${node.short_name}</span> ${node.long_name} <span style=\"color: #ff0;\">${node.id.toString(16)}</span>`;
       resultDiv.addEventListener("mousedown", () => {
        resultsDiv.style.display = "none";
        const freshData = JSON.parse(JSON.stringify(initialData));
        const selectedMesh = getMeshForNode(freshData, node.id);
        reloadSimulation(selectedMesh);

        if(selectedNode)
         unhighlightNode(selectedNode.element, selectedNode.data);

        const nodeElement = d3.select(`[data-id="${node.id}"]`).node();
        selectedNode = {element: nodeElement, data: node};
        startBlinking(selectedNode.element, selectedNode.data);
        showTooltip(node);
       });

       resultsDiv.appendChild(resultDiv);
      });
     }
    }

    const searchBar = document.querySelector(".search-bar");
    const resultsDiv = document.querySelector(".results");

    function showResults(query) {
     const items = Array.from(resultsDiv.querySelectorAll("div"));
     items.forEach(item => {
      if(item.getAttribute("data-entete") === "true")
       item.style.display = "block";
      else if(!query || item.textContent.toLowerCase().includes(query.toLowerCase()))
       item.style.display = "block";
      else
       item.style.display = "none";
     });
    }

    searchBar.addEventListener("input", (event) => {
     const query = event.target.value.trim();
     resultsDiv.style.display = "block";
     showResults(query);
    });

    searchBar.addEventListener("focus", () => {
     resultsDiv.style.display = "block";
     showResults(searchBar.value.trim());
    });

    searchBar.addEventListener("blur", () => {
     resultsDiv.style.display = "none";
    });

    function dragstarted(event, d) {
     if(!event.active)
      simulation.alphaTarget(0.3).restart();
     d.fx = d.x;
     d.fy = d.y;
    }

    function dragged(event, d) {
     d.fx = event.x;
     d.fy = event.y;
    }

    function dragended(event, d) {
     if(!event.active)
      simulation.alphaTarget(0);
     d.fx = null;
     d.fy = null;
    }

    function getMiddle(source, target) {
     return {
      x: (source.x + target.x) / 2,
      y: (source.y + target.y) / 2
     };
    }

    function adjustPosition(source, target, margin) {
     const dx = target.x - source.x;
     const dy = target.y - source.y;
     const distance = Math.sqrt(dx * dx + dy * dy);
     const ratio = (distance - margin) / distance;
     const sourceRatio = margin / distance;

     return {
      sourceX: source.x + dx * sourceRatio,
      sourceY: source.y + dy * sourceRatio,
      targetX: target.x - dx * ratio,
      targetY: target.y - dy * ratio
     };
    }

    populateSearchResults();
    const firstNode = getConnectedComponents(initialData)[0][0];
    const selectedMesh = getMeshForNode(JSON.parse(JSON.stringify(initialData)), firstNode.id);
    reloadSimulation(selectedMesh);
   });
  </script>

  <div class="bottom">
   Meshtastic radio network - LoRa LONG_MODERATE 868 Mhz
  </div>
 </body>
</html>
